<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Windows.UI.Xaml.Media;
using Windows.UI;
using Windows.UI.Text;
using System.Reflection;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Media.Animation;
using Windows.UI.Xaml.Automation;
using Windows.UI.Xaml.Automation.Peers;
using Windows.UI.Xaml.Media.Imaging;

namespace XSRT2 {
    public static class Handler
    {
        <#
        ClassDef(
            "FrameworkElement", 
            false,
            null,
            // UNDONE: what is the scalable story for attached properties?
            //
            new PropEntry[] { 
                new PropEntry() { Name="scrollViewer$verticalScrollBarVisibility", SetBody="{ target.SetValue(ScrollViewer.VerticalScrollBarVisibilityProperty, XamlStringParse<ScrollBarVisibility>(valueToken)); }" },
                new PropEntry() { Name="scrollViewer$horizontalScrollBarVisibility", SetBody="{ target.SetValue(ScrollViewer.HorizontalScrollBarVisibilityProperty, XamlStringParse<ScrollBarVisibility>(valueToken)); }" },


                // UNDONE: rest of grid
                //
                new PropEntry() { Name="grid$row", SetBody="{ target.SetValue(Grid.RowProperty, Convert.ToInt32(valueToken.Value<double>())); }" },
                new PropEntry() { Name="grid$rowSpan", SetBody="{ target.SetValue(Grid.RowSpanProperty, Convert.ToInt32(valueToken.Value<double>())); }" },
                new PropEntry() { Name="grid$column", SetBody="{ target.SetValue(Grid.ColumnProperty, Convert.ToInt32(valueToken.Value<double>())); }" },
                new PropEntry() { Name="grid$columnSpan", SetBody="{ target.SetValue(Grid.ColumnSpanProperty, Convert.ToInt32(valueToken.Value<double>())); }" },

                // UNDONE: rest of accessibility
                //
                new PropEntry() { Name="automationId", SetBody="{ AutomationProperties.SetAutomationId(target, valueToken.ToString()); }" },
                new PropEntry() { Name="acc$helpText", SetBody="{ AutomationProperties.SetHelpText(target, valueToken.ToString()); }" },
                RefAttachedProp("LabeledBy", "acc", "AutomationProperties"),
                EnumAttachedProperty("LiveSetting", "acc", "AutomationProperties", "AutomationLiveSetting"),
                new PropEntry() { Name="acc$name", SetBody="{ AutomationProperties.SetName(target, valueToken.ToString()); }" },

                // This is all of relativePanel
                //
                RefAttachedProp("Above", "relative", "RelativePanel"),
                RefAttachedProp("AlignBottomWith", "relative", "RelativePanel"),
                BooleanAttachedProp("AlignBottomWithPanel", "relative", "RelativePanel" ),
                RefAttachedProp("AlignHorizontalCenterWith", "relative", "RelativePanel"),
                RefAttachedProp("AlignLeftWith", "relative", "RelativePanel"),
                BooleanAttachedProp("AlignLeftWithPanel", "relative", "RelativePanel" ),
                RefAttachedProp("AlignRightWith", "relative", "RelativePanel"),
                BooleanAttachedProp("AlignRightWithPanel", "relative", "RelativePanel" ),
                RefAttachedProp("AlignTopWith", "relative", "RelativePanel"),
                BooleanAttachedProp("AlignTopWithPanel", "relative", "RelativePanel" ),
                RefAttachedProp("AlignVerticalCenterWith", "relative", "RelativePanel"),
                BooleanAttachedProp("AlignVerticalCenterWithPanel", "relative", "RelativePanel" ),
                RefAttachedProp("Below", "relative", "RelativePanel"),
                RefAttachedProp("LeftOf", "relative", "RelativePanel"),
                RefAttachedProp("RightOf", "relative", "RelativePanel"),
                
                // UNDONE: rest of framework element
                //
                EnumProp("HorizontalAlignment"),
                EnumProp("VerticalAlignment"),
                XamlProp("Margin", "Thickness"),
                new PropEntry() { Name="name", SetBody="{ target.Name = valueToken.ToString(); }" }
            },
            null
        ); 
        #>

        <#
        ClassDef(
            "TextBlock",
            true,
            "FrameworkElement",
            new PropEntry[] {
                DefaultStringProp("Text"),
                BasicProp("FontFamily", "new FontFamily(valueToken.ToString())"),
                DoubleProp("FontSize"),
                XamlProp("FontWeight", "FontWeight")
            },
            null
        );
        #>

        <#
        ClassDef(
            "Image",
            true,
            "FrameworkElement",
            new PropEntry[] {
                DeferBasicProp("Source", "new BitmapImage(FromRelativeUri(target, valueToken.ToString(), context))")
            },
            null
        );
        #>
        
        <#
        ClassDef(
            "RichEditBox",
            true,
            "Control",
            new PropEntry[] {
                BooleanProp("AcceptsReturn"),
                new PropEntry() { Name="text", SetBody="target.Document.SetText(TextSetOptions.None, valueToken.ToString())" },
                BooleanProp("IsColorFontEnabled"),
                BooleanProp("IsReadOnly"),
                BooleanProp("IsSpellCheckEnabled"),
                BooleanProp("IsTextPredictionEnabled"),
                StringProp("PlaceholderText"),
                BooleanProp("PreventKeyboardDisplayOnProgrammaticFocus"),
                EnumProp("TextAlignment"),
                EnumProp("TextReadingOrder"),
                EnumProp("TextWrapping")
            },
            new EventEntry[] {
                new EventEntry() { Name="TextChanged", WinRTName="TextChanged", EventType="RoutedEventArgs" }
            }
        );
        #>

        <#
        ClassDef(
            "TextBox",
            true,
            "Control",
            new PropEntry[] {
                BooleanProp("AcceptsReturn"),
                DefaultStringProp("Text"),
                BooleanProp("IsColorFontEnabled"),
                BooleanProp("IsReadOnly"),
                BooleanProp("IsSpellCheckEnabled"),
                BooleanProp("IsTextPredictionEnabled"),
                IntProp("MaxLength"),
                StringProp("PlaceholderText"),
                BooleanProp("PreventKeyboardDisplayOnProgrammaticFocus"),
                IntProp("SelectionLength"),
                IntProp("SelectionStart"),
                EnumProp("TextAlignment"),
                EnumProp("TextReadingOrder"),
                EnumProp("TextWrapping")
            },
            new EventEntry[] {
                new EventEntry() { Name="TextChanged", WinRTName="TextChanged", EventType="RoutedEventArgs" }
            }
        );
        #>

        <#
        ClassDef(
            "GridView",
            true,
            "ListViewBase",
            new PropEntry[] {
            },
            new EventEntry[] {
            }
        );
        #>

        <#
        ClassDef(
            "ListView",
            true,
            "ListViewBase",
            new PropEntry[] {
            },
            new EventEntry[] {
            }
        );
        #>

        <#
        ClassDef(
            "ListViewBase",
            false,
            "Selector",
            new PropEntry[] {
            },
            new EventEntry[] {
            }
        );
        #>
        
        <#
        ClassDef(
            "ComboBox",
            true,
            "Selector",
            new PropEntry[] {
            },
            new EventEntry[] {
            }
        );
        #>
        
        <#
        ClassDef(
            "ListBox",
            true,
            "Selector",
            new PropEntry[] {
            },
            new EventEntry[] {
            }
        );
        #>

        <#
        ClassDef(
            "Selector",
            false,
            "ItemsControl",
            new PropEntry[] {
                new PropEntry() { Name="selectedItem", SetBody="{ target.SelectedItem = CreateForObjectType(valueToken, lastValueToken, context); }" }
            },
            new EventEntry[] {
                new EventEntry() { Name="SelectionChanged", WinRTName="SelectionChanged", EventType="SelectionChangedEventArgs" }
            }
        );
        #>

        <#
        ClassDef(
            "ItemsControl",
            false,
            "Control",
            new PropEntry[] {
                new PropEntry() { Name="itemsSource", SetBody="{ SetItemsSource(target, valueToken, lastValueToken, context); }" },
                new PropEntry() { Name="itemContainerTransitions", SetBody="{ SetItemContainerTransitions(target, valueToken, lastValueToken, context); }" }
            },
            new EventEntry[] {
            }
        );
        #>

        <#
        ClassDef(
            "RangeBase",
            false,
            "Control",
            new PropEntry[] {
            DoubleProp("Minimum"),
            DoubleProp("Maximum"),
            DoubleProp("Value")
            },
            new EventEntry[] {
                new EventEntry() { Name="ValueChanged", WinRTName="ValueChanged", EventType="RangeBaseValueChangedEventArgs" }
            }
        );
        #>

        // UNDONE: Content property (and others) now will recreate when child props change instead of incremental
        // update now that we drop "lastNamedObjectMap" on the floor and track references... 
        // 
        <# ClassDef("Button", true, "ButtonBase", null, null); #>
        <# ClassDef("CalendarDatePicker", true, "Control", null, null); #>
        <# ClassDef("CalendarView", true, "Control", 
            new PropEntry[] {
                DateTimeOffsetProp("MinDate"),
                DateTimeOffsetProp("MaxDate")
            }, null); #>
        <# ClassDef("RelativePanel", true, "Panel", null, null); #>
        <# ClassDef("RepositionThemeTransition", true, null, null, null); #>
        <# ClassDef("ProgressBar", true, "RangeBase", null, null); #>
        <# ClassDef("Slider", true, "RangeBase", null, null); #>
        

        <#
        ClassDef(
            "CheckBox",
            true,
            "ButtonBase",
            new PropEntry[] {
            BooleanProp("IsChecked")
            },
            new EventEntry[] {
                new EventEntry() { Name="Checked", WinRTName="Checked", EventType="RoutedEventArgs" }
            }
        );
        #>

        <#
        ClassDef(
            "ScrollViewer",
            true,
            "ContentControl",
            new PropEntry[] {
                XamlProp("HorizontalScrollBarVisibility", "ScrollBarVisibility"),
                XamlProp("HorizontalScrollMode", "ScrollMode"),
                XamlProp("HorizontalSnapPointsAlignment", "SnapPointsAlignment"),
                XamlProp("HorizontalSnapPointsType", "SnapPointsType"),
                BooleanProp("IsDeferredScrollingEnabled"),
                BooleanProp("IsHorizontalRailEnabled"),
                BooleanProp("IsHorizontalScrollChainingEnabled"),
                BooleanProp("IsScrollInertiaEnabled"),
                BooleanProp("IsVerticalRailEnabled"),
                BooleanProp("IsVerticalScrollChainingEnabled"),
                BooleanProp("IsZoomChainingEnabled"),
                BooleanProp("IsZoomInertiaEnabled"),
                FloatProp("MaxZoomFactor"),
                FloatProp("MinZoomFactor"),
                BasicProp("LeftHeader", "CreateFromState(valueToken, lastValueToken, context) as UIElement"),
                BasicProp("TopHeader", "CreateFromState(valueToken, lastValueToken, context) as UIElement"),
                BasicProp("TopLeftHeader", "CreateFromState(valueToken, lastValueToken, context) as UIElement"),
                XamlProp("VerticalScrollBarVisibility", "ScrollBarVisibility"),
                XamlProp("VerticalScrollMode", "ScrollMode"),
                XamlProp("VerticalSnapPointsAlignment", "SnapPointsAlignment"),
                XamlProp("VerticalSnapPointsType", "SnapPointsType"),
                XamlProp("ZoomMode", "ZoomMode"),
                // UNDONE: public IList<System.Single> ZoomSnapPoints { get; }
                XamlProp("ZoomSnapPointsType", "SnapPointsType")

            },
            null
        );
        #>

        <#
        ClassDef(
            "ButtonBase",
            false,
            "ContentControl",
            new PropEntry[] {
            },
            new EventEntry[] {
                new EventEntry() { Name="Click", WinRTName="Click", EventType="RoutedEventArgs" }
            }
        );
        #>
        
        <#
        ClassDef(
            "ContentControl",
            false,
            "Control",
            new PropEntry[] {
                DefaultBasicProp("Content", "CreateFromState(valueToken, lastValueToken, context)")
            },
            null
        );
        #>

        <#
        ClassDef(
            "Control",
            false,
            "FrameworkElement",
            new PropEntry[] {
                XamlProp("Background", "Brush"),
                XamlProp("Foreground", "Brush"),
                BasicProp("FontFamily", "new FontFamily(valueToken.ToString())"),
                DoubleProp("FontSize"),
                EnumProp("FontWeight")
            },
            null
        );
        #>

        <# ClassDef(
            "StackPanel", 
            true, 
            "Panel", 
            new PropEntry[] { 
                EnumProp("Orientation")
            }, 
            null); #>

        <# 
        ClassDef(
            "Grid", 
            true, 
            "Panel", 
            new PropEntry[] {
                    new PropEntry() { Name="rows", SetBody="{ PanelHandler.SetGridRowDefinitions(target, (JArray)valueToken); }" },
                    new PropEntry() { Name="columns", SetBody="{ PanelHandler.SetGridColumnDefinitions(target, (JArray)valueToken); }" }
            },
            null
        ); 
        #>

        internal static class PanelHandler
        {
            internal static void SetGridRowDefinitions(Grid t, JArray obj) 
            {
                t.RowDefinitions.Clear();
                foreach (var d in obj.AsJEnumerable())
                {
                    RowDefinition rd = new RowDefinition();
                    rd.Height = XamlStringParse<GridLength>(d);
                    t.RowDefinitions.Add(rd);
                }
            }
            internal static void SetGridColumnDefinitions(Grid t, JArray obj) 
            {
                t.ColumnDefinitions.Clear();
                foreach (var d in obj.AsJEnumerable())
                {
                    ColumnDefinition cd = new ColumnDefinition();
                    cd.Width = XamlStringParse<GridLength>(d);
                    t.ColumnDefinitions.Add(cd);
                }
            }

            static void Unparent(UIElement child)
            {
                DependencyObject visualParent = null;

                var fe = child as FrameworkElement;
                if (fe != null && fe.Parent != null)
                {
                    visualParent = fe.Parent;
                }
                if (visualParent == null)
                {
                    visualParent = VisualTreeHelper.GetParent(child);
                }
                var parentContent = visualParent as ContentControl;
                var parentPresenter = visualParent as ContentPresenter;
                var parentBorder = visualParent as Border;
                var parentPanel = visualParent as Panel;
                if (parentPanel != null)
                {
                    parentPanel.Children.Remove(child);
                }
                else if (parentContent != null)
                {
                    parentContent.Content = null;
                }
                else if (parentBorder != null)
                {
                    parentBorder.Child = null;
                }
                else if (parentPresenter != null)
                {
                    parentPresenter.Content = null;
                }
            }

            static void SetPanelChildren(Panel t, JObject obj, JObject lastObj, DiffContext context)
            {
                Handler.FrameworkElementHandler.SetProperties(t, obj, lastObj, context);
                List<UIElement> children = new List<UIElement>();
                IJEnumerable<JToken> lastChildren = null;
                JToken last;
                if (lastObj != null && lastObj.TryGetValue("children", out last))
                {
                    lastChildren = last.AsJEnumerable();
                }
                CollectPanelChildrenWorker(t, obj["children"].AsJEnumerable(), lastChildren, children, context);
                var setChildrenNeeded = false;
                if (t.Children.Count == children.Count)
                {
                    for (int i = 0; i < children.Count; i++)
                    {
                        if (!object.ReferenceEquals(children[i], t.Children[i]))
                        {
                            setChildrenNeeded = true;
                        }
                    }
                }
                else
                {
                    setChildrenNeeded = true;
                }

                if (setChildrenNeeded)
                {
                    t.Children.Clear();
                    foreach (var child in children)
                    {
                        Unparent(child);
                        t.Children.Add(child);
                    }
                }
            }
            static void CollectPanelChildrenWorker(Panel t, IJEnumerable<JToken> items, IEnumerable<JToken> lastItems, List<UIElement> children, DiffContext context)
            {
                IEnumerator<JToken> enumerator = null;
                if (lastItems != null)
                {
                    enumerator = lastItems.GetEnumerator();
                    enumerator.Reset();
                }
                if(items != null)
                {
                    foreach (var child in items)
                    {
                        JToken lastChild = null;
                        if (enumerator != null && enumerator.MoveNext()) { lastChild = enumerator.Current; }

                        if (child.Type == JTokenType.Array)
                        {
                            CollectPanelChildrenWorker(t, child.AsJEnumerable(), lastChild != null ? lastChild.AsJEnumerable() : null, children, context);
                        }
                        else
                        {
                            var instance = CreateFromState((JObject)child, lastChild as JObject, context);
                            children.Add((FrameworkElement)instance);
                        }
                    }
                }
            }
            internal static void SetProperties(Panel t, JObject obj, JObject lastObj, DiffContext context)
            {
                FrameworkElementHandler.SetProperties(t, obj, lastObj, context);
                SetPanelChildren(t, obj, lastObj, context);
                TrySet(context, obj, lastObj, "background", false, t, (target, valueToken, lastValueToken) => target.Background = XamlStringParse<Brush>(valueToken));
                TrySet(context, obj, lastObj, "childrenTransitions", false, t, (target, valueToken, lastValueToken) => { SetChildrenTransitions(target, valueToken, lastValueToken, context); });
            }

        }


        static DependencyProperty eventMap = DependencyProperty.RegisterAttached("XSEventMap", typeof(Dictionary<string, string>), typeof(FrameworkElement), PropertyMetadata.Create((object)null));
        static Dictionary<string, CreateCallback> handlers;

        public static event EventHandler<CommandEventArgs> Command;


        delegate void SetCollectionPropertyCallback<TObject, TValue>(TObject target, List<TValue> items);
        internal static void SetItemContainerTransitions(ItemsControl control, JToken obj, JToken last, Handler.DiffContext context)
        {
            SetCollectionProperty<ItemsControl, Transition>(
                control,
                "itemContainerTransitions",
                obj,
                last,
                context,
                (target, list) =>
                {
                    target.ItemContainerTransitions.Clear();
                    foreach (var child in list)
                    {
                        target.ItemContainerTransitions.Add(child);
                    }
                });

        }
        internal static void SetChildrenTransitions(Panel control, JToken obj, JToken last, Handler.DiffContext context)
        {
            SetCollectionProperty<Panel, Transition>(
                control,
                "itemContainerTransitions",
                obj,
                last,
                context,
                (target, list) =>
                {
                    TransitionCollection col = target.ChildrenTransitions;
                    if (col == null)
                    {
                        target.ChildrenTransitions = col = new TransitionCollection();
                    }
                    else
                    {
                        col.Clear();
                    }
                    foreach (var child in list)
                    {
                        col.Add(child);
                    }
                });

        }

        static void SetCollectionProperty<TObject, TValue>(
            TObject t, 
            string propertyName,
            JToken obj,
            JToken lastObj,
            Handler.DiffContext context, 
            SetCollectionPropertyCallback<TObject, TValue> setter) where TValue : DependencyObject
        {
            List<TValue> children = new List<TValue>();
            IJEnumerable<JToken> lastChildren = null;
            if (lastObj != null)
            {
                lastChildren = lastObj.AsJEnumerable();
            }
            CollectItemsWorker(t, obj.AsJEnumerable(), lastChildren, children, context);
            // UNDONE: better diff
            //
            var setChildrenNeeded = true;

            if (setChildrenNeeded)
            {
                setter(t, children);
            }
        }
        static void CollectItemsWorker<TObject, TValue>(
            TObject t, 
            IJEnumerable<JToken> items, 
            IEnumerable<JToken> lastItems, 
            List<TValue> children,
            Handler.DiffContext context) where TValue : DependencyObject
        {
            IEnumerator<JToken> enumerator = null;
            if (lastItems != null)
            {
                enumerator = lastItems.GetEnumerator();
                enumerator.Reset();
            }
            foreach (var child in items)
            {
                JToken lastChild = null;
                if (enumerator != null && enumerator.MoveNext()) { lastChild = enumerator.Current; }

                if (child.Type == JTokenType.Array)
                {
                    CollectItemsWorker(t, child.AsJEnumerable(), lastChild != null ? lastChild.AsJEnumerable() : null, children, context);
                }
                else
                {
                    var instance = Handler.CreateFromState((JObject)child, lastChild as JObject, context);
                    children.Add((TValue)instance);
                }
            }
        }

        internal static object CreateForObjectType(JToken obj, JToken objLast, Handler.DiffContext context)
        {
            switch (obj.Type)
            {
                case JTokenType.Float:
                    return obj.Value<double>();
                case JTokenType.Integer:
                    return obj.Value<int>();
                case JTokenType.String:
                    return obj.Value<string>();
                case JTokenType.Object:
                    var instance = Handler.CreateFromState((JObject)obj, objLast as JObject, context);
                    return instance;
                default:
                    return "Unhandled:" + Enum.GetName(typeof(JTokenType), obj.Type);
            }
        }

        internal static void SetItemsSource(ItemsControl control, JToken source, JToken lastSource, Handler.DiffContext context)
        {
            // UNDONE: need to do delta on previous version of the list
            //
            List<object> collection = new List<object>();
            if (source.Type == JTokenType.Array)
            {
                foreach (var child in source.AsJEnumerable())
                {
                    collection.Add(CreateForObjectType(child, lastSource, context));
                }
            }

            control.ItemsSource = collection;
        }

        static CreateResult<T> CreateOrGetLast<T>(JObject obj, DiffContext context) where T:new()
        {
            JToken name;
            string resolvedName = null;
            if (obj.TryGetValue("name", out name))
            {
                resolvedName = name.ToString();
            }
            else
            {
                resolvedName = context.CreateSurrogateName(obj);
            }

            if (resolvedName != null)
            { 
                object value;
                if (context.TryGetObject(resolvedName, out value))
                {
                    if (value != null && value is T)
                    {
                        return new CreateResult<T>() { Value = (T)value, Recycled = true, Name = resolvedName };
                    }
                }
            }
            context.ObjectCreateCount++;
            var instance = new T();
            context.AddObject(resolvedName, instance);
            return new CreateResult<T>() { Value = instance, Recycled = false, Name = resolvedName };
        }

        static void TrySet<T>(DiffContext context, JObject obj, JObject last, string name, T target, Setter<T> setter)
        {
            TrySet<T>(context, obj, last, name, false, target, setter);
        }
        static void TrySet<T>(DiffContext context, JObject obj, JObject last, string name, bool aliasFirstChild, T target, Setter<T> setter)
        {
            TrySet<T>(context, obj, last, name, aliasFirstChild, target, setter, null);
        }
        static void TrySet<T>(DiffContext context, JObject obj, JObject last, string name, bool aliasFirstChild, T target, Setter<T> setter, List<DeferSetter> defer)
        {
            JToken tok;
            JToken tokLast = null;
            bool found = false;
            if (!obj.TryGetValue(name, out tok))
            {
                if (aliasFirstChild && obj.TryGetValue("children", out tok))
                {
                    found = true;
                    tok = ((JArray)tok).First;
                }
            }
            else
            {
                found = true;
            }
            if (found)
            {
                if (last != null)
                {
                    if (!last.TryGetValue(name, out tokLast))
                    {
                        if (aliasFirstChild && last.TryGetValue("children", out tokLast))
                        {
                            tokLast = ((JArray)tokLast).First;
                        }
                    }

                    if (tokLast != null && tokLast.ToString() == tok.ToString())
                    {
                        return; // bail early if old & new are the same
                    }
                }
                context.PropertySetCount++;
                if (defer != null) 
                {
                    defer.Add(new DeferSetter<T>() { setter = setter, target = target, tok = tok, tokLast = tokLast });
                }
                else 
                {
                    setter(target, tok, tokLast);
                }
            }
        }
        static void TrySetEvent<T>(DiffContext context, JObject obj, JObject last, string name, T target, Setter<T> setter)
        {
            JToken tok;
            JToken tokLast = null;
            if (obj.TryGetValue("on" + name, out tok))
            {
                if (last != null && last.TryGetValue("on" + name, out tokLast))
                {
                    if (tokLast.ToString() == tok.ToString())
                    {
                        return; // bail early if old & new are the same
                    }
                }
                context.EventSetCount++;
                setter(target, tok, tokLast);
            }
        }
        static T ParseEnum<T>(JToken v) 
        {
            return (T)Enum.Parse(typeof(T), v.ToString());
        }
        static T XamlStringParse<T>(JToken v)
        {
            return (T)Windows.UI.Xaml.Markup.XamlBindingHelper.ConvertValue(typeof(T), v.ToString());
        }
        static Dictionary<string, CreateCallback> GetHandlers()
        {
            if (handlers == null)
            {
                handlers = new Dictionary<string, CreateCallback>();
<# foreach (var name in publicHandlerNames) { #>
                handlers["<#= name #>"] = <#= name #>Handler.Create;
<# } #>
            }
            return handlers;
        }
        internal static DependencyObject CreateFromState(JToken item, JToken lastItem, DiffContext context)
        {
            if (item.Type == JTokenType.Object)
            {
                var type = item["type"].ToString();
                CreateCallback create;
                if (GetHandlers().TryGetValue(type, out create))
                {
                    return create((JObject)item, (JObject)lastItem, context);
                }
                return new TextBlock() { FontSize = 48, Text = "'" + type + "'Not found" };
            }
            else
            {
                return new TextBlock() { Text = item.ToString() };
            }
        }
        internal static Uri FromRelativeUri(FrameworkElement relativeElement, string path, DiffContext context)
        {
            var r = relativeElement;
            var b = r.BaseUri;
            while (b == null)
            {
                r = VisualTreeHelper.GetParent(r) as FrameworkElement;
                if (r == null) { b = context.HostElement.BaseUri; break; }
                b = r.BaseUri;
            }
            if (b == null) { throw new InvalidOperationException("Can't determine base uri"); }
            var u = new Uri(b, path);
            return u;
        }

        internal delegate void Setter<T>(T target, JToken value, JToken lastValue);
        delegate DependencyObject CreateCallback(JObject obj, JObject lastObj, DiffContext context);

        struct CreateResult<T> 
        {
            public T Value;
            public bool Recycled;
            public string Name;
        }
        internal abstract class DeferSetter
        {
            public abstract void Do();
        }
        internal class DeferSetter<T> : DeferSetter
        {
            internal T target;
            internal JToken tok;
            internal JToken tokLast;
            internal Setter<T> setter;

            public override void Do()
            {
                setter(target, tok, tokLast);
            }
        }
        internal class DiffContext 
        {
            Dictionary<string, object> lastNamedObjectMap;
            Dictionary<string, object> currentNamedObjectMap = new Dictionary<string, object>();
            Dictionary<string, int> surrogateKeys = new Dictionary<string, int>();
            List<string> nameStack = new List<string>();

            internal DiffContext(Dictionary<string, object> lastNamedObjectMap)
            {
                this.lastNamedObjectMap = lastNamedObjectMap;
            }

            public List<DeferSetter> Defer;
            public int EventSetCount;
            public int PropertySetCount;
            public int ObjectCreateCount;
            public DateTime Start;
            public DateTime End;
            public FrameworkElement HostElement;
                
            public Dictionary<String, object> GetNamedObjectMap() { return currentNamedObjectMap; }

            public object ReferenceObject(string name) 
            {
                object value;
                if (lastNamedObjectMap.TryGetValue(name, out value))
                {
                    currentNamedObjectMap[name] = value;
                    return value;
                }
                return null;
            }
            public bool TryGetObject(string name, out object value)
            {
                var ret = lastNamedObjectMap.TryGetValue(name, out value);
                if (ret) { currentNamedObjectMap[name] = value; }
                return ret;
            }
            public void AddObject(string name, object value)
            {
                lastNamedObjectMap[name] = currentNamedObjectMap[name] = value;
            }
            public string CreateSurrogateName(JObject obj) 
            { 
                string baseName = "xsrt";
                JToken t;
                if (obj.TryGetValue("type", out t))
                {
                    baseName = t.ToString();
                }
                int n = 0;
                if (surrogateKeys.TryGetValue(baseName, out n)) 
                {
                    n++;
                }
                surrogateKeys[baseName] = n;
                string key = baseName + n;

                var concat = nameStack.Count > 0 ? nameStack.Aggregate((a, b) => a + "-" + b) : "root";
                 
                return concat + "-" + key;
            }
            public void PushName(string name)
            {
                nameStack.Add(name);
            }
            public void PopName(string name)
            {
                var n = nameStack[nameStack.Count - 1];
                if (name != n) { throw new InvalidOperationException("unbalanced name"); }
                nameStack.RemoveAt(nameStack.Count - 1);
            }
        }
    }
}

<#+
List<string> publicHandlerNames = new List<string>();

class PropEntry {
    public string Name;
    public bool AliasFirstChild = false;
    public bool Defer = false;
    public string SetBody;
}
class EventEntry {
    public string Name;
    public string WinRTName;
    public string EventType;
}
string CamelCase(string name) {
    return Char.ToLowerInvariant(name[0]) + name.Substring(1);
}
PropEntry EnumProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = ParseEnum<" + name + ">(valueToken)" };
}
PropEntry EnumProp(string name, string winRTTypeName) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = ParseEnum<" + winRTTypeName + ">(valueToken)" };
}
PropEntry XamlProp(string name, string typeName) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = XamlStringParse<" + typeName + ">(valueToken)" };
}
PropEntry IntProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = valueToken.Value<int>()" };
}
PropEntry FloatProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = valueToken.Value<float>()" };
}
PropEntry StringProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = valueToken.ToString()" };
}
PropEntry DefaultStringProp(string name) {
    return new PropEntry() { Name=CamelCase(name), AliasFirstChild=true, SetBody="target." + name + " = valueToken.ToString()" };
}
PropEntry BasicProp(string name, string setter) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = " + setter };
}
PropEntry DeferBasicProp(string name, string setter) {
    return new PropEntry() { Name=CamelCase(name), Defer=true, SetBody="target." + name + " = " + setter };
}
PropEntry DefaultBasicProp(string name, string setter) {
    return new PropEntry() { Name=CamelCase(name), AliasFirstChild=true, SetBody="target." + name + " = " + setter };
}
PropEntry DoubleProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = valueToken.Value<double>()" };
}
PropEntry DateTimeOffsetProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = DateTimeOffset.Parse(valueToken.ToString())" };
}
PropEntry BooleanProp(string name) {
    return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = Convert.ToBoolean(((JValue)valueToken).Value)" };
}
PropEntry EnumAttachedProperty(string winRTPropName, string shortProvider, string winRTProvider, string winRTEnumType) {
    return new PropEntry() { Name=shortProvider + "$" + CamelCase(winRTPropName), SetBody="target.SetValue("+winRTProvider+"."+winRTPropName+"Property, ParseEnum<" + winRTEnumType + ">(valueToken))" };
}
PropEntry BooleanAttachedProp(string winRTPropName, string shortProvider, string winRTProvider) {
    return new PropEntry() { Name=shortProvider + "$" + CamelCase(winRTPropName), SetBody="target.SetValue("+winRTProvider+"."+winRTPropName+"Property, Convert.ToBoolean(Convert.ToBoolean(((JValue)valueToken).Value)))" };
}
PropEntry RefAttachedProp(string winRTPropName, string shortProvider, string winRTProvider) {
    return new PropEntry() { 
        Name=shortProvider + "$" + CamelCase(winRTPropName), 
        SetBody="target.SetValue("+winRTProvider+"."+winRTPropName+"Property, context.ReferenceObject(valueToken.ToString()))",
        Defer = true
    };
}
void ClassDef(string name, bool isPublic, string baseTypeName, PropEntry[] props, EventEntry[] events) {
    if (isPublic) { publicHandlerNames.Add(name); }
    PushIndent("    ");
    PushIndent("    ");
    WriteLine("internal static class " + name + "Handler");
    WriteLine("{");
    PushIndent("    ");
    if (isPublic) {
        Create(name);
    }
    PropSetter(name, baseTypeName, props, events);
    if (events != null) {
        foreach (var e in events) {
            EventHandler(e.WinRTName, e.EventType, name);
        }
    }
    PopIndent();
    WriteLine("}");
    PopIndent();
    PopIndent();
}
void Create(string name) {
    WriteLine("internal static " + name + " Create(JObject obj, JObject lastObj, DiffContext context)");
    WriteLine("{");
    PushIndent("    ");
    WriteLine("var createResult = CreateOrGetLast<" + name + ">(obj, context);");
    WriteLine("context.PushName(createResult.Name);");
    WriteLine("SetProperties(createResult.Value, obj, createResult.Recycled ? lastObj : null, context);");
    WriteLine("context.PopName(createResult.Name);");
    WriteLine("return createResult.Value;");
    PopIndent();
    WriteLine("}");
}
void PropSetter(string name, string baseTypeName, PropEntry[] props, EventEntry[] events) {
    WriteLine("internal static void SetProperties(" + name + " t, JObject obj, JObject lastObj, DiffContext context)");
    WriteLine("{");
    PushIndent("    ");
    if (baseTypeName != null && baseTypeName.Length > 0)
    {
        WriteLine(baseTypeName + "Handler.SetProperties(t, obj, lastObj, context);");
    }
    if (props != null) {
        foreach (var prop in props) {
            string deferArg = "";
            if (prop.Defer) {
                deferArg = ", context.Defer";
            }
            string alias = prop.AliasFirstChild ? "true" : "false";
            WriteLine("TrySet(context, obj, lastObj,");
            WriteLine("    \"" + prop.Name + "\", ");
            WriteLine("    " + alias + ",");
            WriteLine("    t,");
            WriteLine("    (target, valueToken, lastValueToken) => " + prop.SetBody + deferArg + ");");
        }
    }
    if (events != null) {
        foreach (var e in events) {
            WriteLine("TrySetEvent(context, obj, lastObj, \"" + e.Name + "\", t, (target, valueToken, lastValueToken) => Set"+e.WinRTName+"EventHandler(valueToken.ToString(), target));");
        }
    }
                
    PopIndent();
    WriteLine("}");
}

void EventHandler(string eventName, string eventTypeName, string typeName) {
    WriteLine("static void "+eventName+"Router(object sender, "+eventTypeName+" e)");
    WriteLine("{");
    PushIndent("    ");
    WriteLine("if (Command != null)");
    WriteLine("{");
    PushIndent("    ");
    WriteLine("var map = (Dictionary<string, string>)((FrameworkElement)sender).GetValue(eventMap);");
    WriteLine("Command(null, new CommandEventArgs() { CommandHandlerToken = map[\""+eventName+"\"], Sender = sender, EventArgs = e });");
    PopIndent();
    WriteLine("}");
    PopIndent();
    WriteLine("}");

    WriteLine("static void Set"+eventName+"EventHandler(string handlerName, "+typeName+" element)");
    WriteLine("{");
    PushIndent("    ");
    WriteLine("var map = (Dictionary<string, string>)element.GetValue(eventMap);");
    WriteLine("if (map == null)");
    WriteLine("{");
    PushIndent("    ");
    WriteLine("element.SetValue(eventMap, map = new Dictionary<string, string>());");
    PopIndent();
    WriteLine("}");
    WriteLine("map[\""+eventName+"\"] = handlerName;");
    // remove to avoid duplicates   
    //
    WriteLine("element."+eventName+" -= "+eventName+"Router;");
    WriteLine("element."+eventName+" += "+eventName+"Router;");
    PopIndent();
    WriteLine("}");
}
#>
