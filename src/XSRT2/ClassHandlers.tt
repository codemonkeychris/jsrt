<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Windows.UI.Xaml.Media;
using Windows.UI;
using Windows.UI.Text;
using System.Reflection;
using Windows.UI.Xaml.Controls.Primitives;

namespace XSRT2 {
	public static class Handler
	{
		<#
		ClassDef(
			"FrameworkElement", 
			false,
			null,
			new PropEntry[] { 
				EnumProperty("HorizontalAlignment"),
				EnumProperty("VerticalAlignment"),
				XamlProperty("Margin", "Thickness"),
				new PropEntry() { Name="name", SetBody="{ target.Name = x.ToString(); namedObjectMap[target.Name] = target; }" }
			},
			null
		); 
		#>

		<#
		ClassDef(
			"TextBlock",
			true,
			"FrameworkElement",
			new PropEntry[] {
				StringProp("Text"),
				BasicProp("FontFamily", "new FontFamily(x.ToString())"),
				DoubleProp("FontSize"),
				EnumProperty("FontWeight")
			},
			null
		);
		#>

		<#
		ClassDef(
			"ButtonBase",
			false,
			"Control",
			new PropEntry[] {
				BasicProp("Content", "CreateFromState(x, lastX, namedObjectMap)")
			},
			new EventEntry[] {
				new EventEntry() { Name="click", WinRTName="Click", EventType="RoutedEventArgs" }
			}
		);
		#>

		<#
		ClassDef(
			"Control",
			false,
			"FrameworkElement",
			new PropEntry[] {
				XamlProperty("Background", "Brush"),
				XamlProperty("Foreground", "Brush"),
				BasicProp("FontFamily", "new FontFamily(x.ToString())"),
				DoubleProp("FontSize"),
				EnumProperty("FontWeight")
			},
			null
		);
		#>

        static DependencyProperty eventMap = DependencyProperty.RegisterAttached("XSEventMap", typeof(Dictionary<string, string>), typeof(FrameworkElement), PropertyMetadata.Create((object)null));
        static Dictionary<string, CreateCallback> handlers;

        public static event EventHandler<CommandEventArgs> Command;

        static Tuple<bool, T> CreateOrGetLast<T>(JObject obj, Dictionary<string, object> namedObjectMap) where T:new()
        {
            JToken name;
            if (obj.TryGetValue("name", out name))
            {
                object value;
                if (namedObjectMap.TryGetValue(name.ToString(), out value))
                {
                    if (value != null && value is T)
                    {
                        return new Tuple<bool, T>(true, (T)value);
                    }
                }
            }
            return new Tuple<bool, T>(false, new T());
        }
        static void TrySet<T>(JObject obj, JObject last, string name, T target, Setter<T> setter)
        {
            JToken tok;
            JToken tokLast = null;
            if (obj.TryGetValue(name, out tok))
            {
                if (last != null && last.TryGetValue(name, out tokLast))
                {
                    if (tokLast.ToString() == tok.ToString())
                    {
                        return; // bail early if old & new are the same
                    }
                }
                setter(target, tok, tokLast);
            }
        }
        static void TrySetEvent<T>(JObject obj, JObject last, string name, T target, Setter<T> setter)
        {
            JToken tok;
            JToken tokLast = null;
            if (obj.TryGetValue("$" + name, out tok))
            {
                if (last != null && last.TryGetValue("$" + name, out tokLast))
                {
                    if (tokLast.ToString() == tok.ToString())
                    {
                        return; // bail early if old & new are the same
                    }
                }
                setter(target, tok, tokLast);
            }
        }
        static T ParseEnum<T>(JToken v) 
        {
            return (T)Enum.Parse(typeof(T), v.ToString());
        }
        static T XamlStringParse<T>(JToken v)
        {
            return (T)Windows.UI.Xaml.Markup.XamlBindingHelper.ConvertValue(typeof(T), v.ToString());
        }
        static Dictionary<string, CreateCallback> GetHandlers()
        {
            if (handlers == null)
            {
                handlers = new Dictionary<string, CreateCallback>();
<# foreach (var name in publicHandlerNames) { #>
                handlers["<#= name #>"] = <#= name #>Handler.Create;
<# } #>
            }
            return handlers;
        }
        static FrameworkElement CreateFromState(JToken item, JToken lastItem, Dictionary<string, object> namedObjectMap)
        {
            if (item.Type == JTokenType.Object)
            {
                var type = item["type"].ToString();
                CreateCallback create;
                if (GetHandlers().TryGetValue(type, out create))
                {
                    return create((JObject)item, (JObject)lastItem, namedObjectMap);
                }
                return new TextBlock() { FontSize = 48, Text = "'" + type + "'Not found" };
            }
            else
            {
                return new TextBlock() { Text = item.ToString() };
            }
        }

        delegate void Setter<T>(T target, JToken value, JToken lastValue);
        delegate FrameworkElement CreateCallback(JObject obj, JObject lastObj, Dictionary<string, object> namedObjectMap);

	}
	
}

<#+
List<string> publicHandlerNames = new List<string>();

class PropEntry {
	public string Name;
	public string SetBody;
}
class EventEntry {
	public string Name;
	public string WinRTName;
	public string EventType;
}
string CamelCase(string name) {
	return Char.ToLowerInvariant(name[0]) + name.Substring(1);
}
PropEntry EnumProperty(string name) {
	return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = ParseEnum<" + name + ">(x)" };
}
PropEntry XamlProperty(string name, string typeName) {
	return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = XamlStringParse<" + typeName + ">(x)" };
}
PropEntry StringProp(string name) {
	return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = x.ToString()" };
}
PropEntry BasicProp(string name, string setter) {
	return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = " + setter };
}
PropEntry DoubleProp(string name) {
	return new PropEntry() { Name=CamelCase(name), SetBody="target." + name + " = x.Value<double>()" };
}
void ClassDef(string name, bool isPublic, string baseTypeName, PropEntry[] props, EventEntry[] events) {
	if (isPublic) { publicHandlerNames.Add(name); }
	PushIndent("    ");
	PushIndent("    ");
    WriteLine("internal static class " + name + "Handler");
    WriteLine("{");
	PushIndent("    ");
	if (isPublic) {
		Create(name);
	}
	PropSetter(name, baseTypeName, props, events);
	if (events != null) {
		foreach (var e in events) {
			EventHandler(e.WinRTName, e.EventType, name);
		}
	}
	PopIndent();
    WriteLine("}");
	PopIndent();
	PopIndent();
}
void Create(string name) {
	WriteLine("internal static " + name + " Create(JObject obj, JObject lastObj, Dictionary<string, object> namedObjectMap)");
	WriteLine("{");
	PushIndent("    ");
	WriteLine("var createResult = CreateOrGetLast<" + name + ">(obj, namedObjectMap);");
	WriteLine("SetProperties(createResult.Item2, obj, createResult.Item1 ? lastObj : null, namedObjectMap);");
	WriteLine("return createResult.Item2;");
	PopIndent();
	WriteLine("}");
}
void PropSetter(string name, string baseTypeName, PropEntry[] props, EventEntry[] events) {
	WriteLine("internal static void SetProperties(" + name + " t, JObject obj, JObject lastObj, Dictionary<string, object> namedObjectMap)");
    WriteLine("{");
	PushIndent("    ");
	if (baseTypeName != null && baseTypeName.Length > 0)
	{
		WriteLine(baseTypeName + "Handler.SetProperties(t, obj, lastObj, namedObjectMap);");
	}
	foreach (var prop in props) {
		WriteLine("TrySet(obj, lastObj, \"" + prop.Name + "\", t, (target, x, lastX) => " + prop.SetBody +");");
	}
	if (events != null) {
		foreach (var e in events) {
			WriteLine("TrySetEvent(obj, lastObj, \"" + e.Name + "\", t, (target, x, lastX) => Set"+e.WinRTName+"EventHandler(x.ToString(), target));");
		}
	}
                
	PopIndent();
    WriteLine("}");
}

void EventHandler(string eventName, string eventTypeName, string typeName) {
	WriteLine("static void "+eventName+"Router(object sender, "+eventTypeName+" e)");
	WriteLine("{");
	PushIndent("    ");
	WriteLine("if (Command != null)");
	WriteLine("{");
	PushIndent("    ");
	WriteLine("var map = (Dictionary<string, string>)((FrameworkElement)sender).GetValue(eventMap);");
	WriteLine("Command(null, new CommandEventArgs() { CommandHandlerToken = map[\""+eventName+"\"], Sender = sender, EventArgs = e });");
	PopIndent();
	WriteLine("}");
	PopIndent();
	WriteLine("}");

	WriteLine("static void Set"+eventName+"EventHandler(string handlerName, "+typeName+" element)");
	WriteLine("{");
	PushIndent("    ");
	WriteLine("var map = (Dictionary<string, string>)element.GetValue(eventMap);");
	WriteLine("if (map == null)");
	WriteLine("{");
	PushIndent("    ");
	WriteLine("element.SetValue(eventMap, map = new Dictionary<string, string>());");
	PopIndent();
	WriteLine("}");
	WriteLine("map[\""+eventName+"\"] = handlerName;");
	// remove to avoid duplicates   
	//
	WriteLine("element.Click -= "+eventName+"Router;");
	WriteLine("element.Click += "+eventName+"Router;");
	PopIndent();
	WriteLine("}");
}
#>
